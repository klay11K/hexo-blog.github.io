<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>MySQL 进阶 | klay的知识星球</title>
  <meta name="description" content="MySQL 进阶MySQL 架构如图所示，MySQL  架构分为三层  连接层 服务层（解析与优化） 存储引擎层       引用于《MySQL 是怎样运行的：从根儿上理解 MySQL》 连接层 客户端发起连接请求时，连接层会验证客户端携带的主机名，用户名和密码是否正确。 建立连接后，会验证客户端是否拥有操作数据库的权限。  服务层查询缓存 一条查询语句进入服务层后，会先进行查询缓存，如果缓存中已">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL 进阶">
<meta property="og:url" content="http://example.com/2023/05/19/MySQL/mysql-%E8%BF%9B%E9%98%B6/index.html">
<meta property="og:site_name" content="努力沉淀">
<meta property="og:description" content="MySQL 进阶MySQL 架构如图所示，MySQL  架构分为三层  连接层 服务层（解析与优化） 存储引擎层       引用于《MySQL 是怎样运行的：从根儿上理解 MySQL》 连接层 客户端发起连接请求时，连接层会验证客户端携带的主机名，用户名和密码是否正确。 建立连接后，会验证客户端是否拥有操作数据库的权限。  服务层查询缓存 一条查询语句进入服务层后，会先进行查询缓存，如果缓存中已">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/image/mysql-%E8%BF%9B%E9%98%B6.assets/image-20230401093434378.png">
<meta property="og:image" content="http://example.com/image/mysql-%E8%BF%9B%E9%98%B6.assets/image-20230401124842469.png">
<meta property="og:image" content="http://example.com/image/mysql-%E8%BF%9B%E9%98%B6.assets/image-20230405212706534.png">
<meta property="og:image" content="http://example.com/image/mysql-%E8%BF%9B%E9%98%B6.assets/image-20230406204525186.png">
<meta property="og:image" content="http://example.com/image/mysql-%E8%BF%9B%E9%98%B6.assets/image-20230406210455128.png">
<meta property="og:image" content="http://example.com/image/mysql-%E8%BF%9B%E9%98%B6.assets/image-20230411181138105.png">
<meta property="og:image" content="http://example.com/mysql-%E8%BF%9B%E9%98%B6.assets/image-20230412003347844.png">
<meta property="og:image" content="http://example.com/image/mysql-%E8%BF%9B%E9%98%B6.assets/image-20230412230901365.png">
<meta property="og:image" content="http://example.com/image/mysql-%E8%BF%9B%E9%98%B6.assets/image-20230412232619116.png">
<meta property="og:image" content="http://example.com/image/mysql-%E8%BF%9B%E9%98%B6.assets/image-20230412003226986.png">
<meta property="og:image" content="http://example.com/image/mysql-%E8%BF%9B%E9%98%B6.assets/image-20230413231430770.png">
<meta property="og:image" content="http://example.com/image/mysql-%E8%BF%9B%E9%98%B6.assets/image-20230412234130085.png">
<meta property="og:image" content="http://example.com/image/mysql-%E8%BF%9B%E9%98%B6.assets/image-20230412233911129.png">
<meta property="og:image" content="http://example.com/image/mysql-%E8%BF%9B%E9%98%B6.assets/image-20230412234005160.png">
<meta property="og:image" content="http://example.com/image/mysql-%E8%BF%9B%E9%98%B6.assets/image-20230413233100799.png">
<meta property="og:image" content="http://example.com/image/mysql-%E8%BF%9B%E9%98%B6.assets/image-20230413233433058.png">
<meta property="og:image" content="http://example.com/image/mysql-%E8%BF%9B%E9%98%B6.assets/image-20230413235212693.png">
<meta property="article:published_time" content="2023-05-18T22:46:09.342Z">
<meta property="article:modified_time" content="2023-05-18T22:50:52.610Z">
<meta property="article:author" content="klay">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/image/mysql-%E8%BF%9B%E9%98%B6.assets/image-20230401093434378.png">
  <!-- Canonical links -->
  <link rel="canonical" href="http://example.com/2023/05/19/MySQL/mysql-%E8%BF%9B%E9%98%B6/index.html">
  
    <link rel="alternate" href="/atom.xml" title="努力沉淀" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.2"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/klay11K/klay11K.github.io" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/HTML/">HTML</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a><span class="category-list-count">5</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E5%9F%BA%E7%A1%80/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/">函数式编程</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/PDF/">PDF</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/">微信小程序</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/">踩坑记录</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag">Java基础</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E9%9B%86%E5%90%88/" rel="tag">Java集合</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Junit/" rel="tag">Junit</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PDF/" rel="tag">PDF</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/github/" rel="tag">github</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" rel="tag">函数式编程</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" rel="tag">微信小程序</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" rel="tag">计算机基础</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/HTML/" style="font-size: 13px;">HTML</a> <a href="/tags/Hexo/" style="font-size: 14px;">Hexo</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 13.5px;">Java基础</a> <a href="/tags/Java%E9%9B%86%E5%90%88/" style="font-size: 13px;">Java集合</a> <a href="/tags/Junit/" style="font-size: 13px;">Junit</a> <a href="/tags/MySQL/" style="font-size: 13px;">MySQL</a> <a href="/tags/PDF/" style="font-size: 13px;">PDF</a> <a href="/tags/github/" style="font-size: 13px;">github</a> <a href="/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" style="font-size: 13px;">函数式编程</a> <a href="/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" style="font-size: 13px;">微信小程序</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" style="font-size: 13px;">计算机基础</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 13px;">计算机网络</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 13px;">设计模式</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/06/">六月 2023</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">五月 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">四月 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">二月 2023</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">一月 2023</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">十二月 2022</a><span class="archive-list-count">4</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/PDF/">PDF</a>
              </p>
              <p class="item-title">
                <a href="/2023/06/19/PDF/Java%20%E5%AE%9E%E7%8E%B0%20PDF%20%E7%94%9F%E6%88%90/" class="title">Java 实现 PDF 生成</a>
              </p>
              <p class="item-date">
                <time datetime="2023-06-19T02:04:06.448Z" itemprop="datePublished">2023-06-19</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a><i class="icon icon-angle-right"></i><a class="category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
              </p>
              <p class="item-title">
                <a href="/2023/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="title">计算机网络</a>
              </p>
              <p class="item-date">
                <time datetime="2023-06-08T03:24:13.606Z" itemprop="datePublished">2023-06-08</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a><i class="icon icon-angle-right"></i><a class="category-link" href="/categories/Java%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
              </p>
              <p class="item-title">
                <a href="/2023/06/08/java%E5%9F%BA%E7%A1%80/23%E7%A7%8DJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%BB%91%E9%A9%AC/" class="title">23种设计模式（Java 实现方式）</a>
              </p>
              <p class="item-date">
                <time datetime="2023-06-08T01:33:18.264Z" itemprop="datePublished">2023-06-08</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/MySQL/">MySQL</a>
              </p>
              <p class="item-title">
                <a href="/2023/05/19/MySQL/mysql-%E8%BF%9B%E9%98%B6/" class="title">MySQL 进阶</a>
              </p>
              <p class="item-date">
                <time datetime="2023-05-18T22:46:09.342Z" itemprop="datePublished">2023-05-19</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/">踩坑记录</a>
              </p>
              <p class="item-title">
                <a href="/2023/04/28/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/Junit5-%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/" class="title">Junit 踩坑记录</a>
              </p>
              <p class="item-date">
                <time datetime="2023-04-28T09:10:22.913Z" itemprop="datePublished">2023-04-28</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
  <aside class="sidebar sidebar-toc collapse   in  " id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL-%E8%BF%9B%E9%98%B6"><span class="toc-number">1.</span> <span class="toc-text">MySQL 进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL-%E6%9E%B6%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text">MySQL 架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E5%B1%82"><span class="toc-number">1.1.1.</span> <span class="toc-text">连接层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%B1%82"><span class="toc-number">1.1.2.</span> <span class="toc-text">服务层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">查询缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E8%A7%A3%E6%9E%90"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">语法解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">查询优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%B1%82"><span class="toc-number">1.1.3.</span> <span class="toc-text">存储引擎层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">1.1.4.</span> <span class="toc-text">SQL 执行流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-number">1.2.</span> <span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95"><span class="toc-number">1.2.1.</span> <span class="toc-text">什么是索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-number">1.2.2.</span> <span class="toc-text">索引的优缺点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B2%A1%E6%9C%89%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9F%A5%E6%89%BE%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.3.</span> <span class="toc-text">没有索引的查找方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88"><span class="toc-number">1.2.4.</span> <span class="toc-text">索引的设计方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Comcact-%E8%A1%8C%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.2.5.</span> <span class="toc-text">Comcact 行格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.6.</span> <span class="toc-text">索引的数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#B-%E6%A0%91"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">B+ 树</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.3.</span> <span class="toc-text">索引的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="toc-number">1.3.1.</span> <span class="toc-text">聚簇索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95"><span class="toc-number">1.3.2.</span> <span class="toc-text">二级索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="toc-number">1.3.3.</span> <span class="toc-text">联合索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB-%E7%9A%84-B-%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.4.</span> <span class="toc-text">InnoDB 的 B+ 树索引的注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E9%A1%B5%E9%9D%A2%E4%B8%87%E5%B9%B4%E4%B8%8D%E5%8A%A8%E7%AA%9D"><span class="toc-number">1.4.1.</span> <span class="toc-text">根页面万年不动窝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E8%8A%82%E7%82%B9%E4%B8%AD%E7%9B%AE%E5%BD%95%E9%A1%B9%E8%AE%B0%E5%BD%95%E7%9A%84%E5%94%AF%E4%B8%80%E6%80%A7"><span class="toc-number">1.4.2.</span> <span class="toc-text">内节点中目录项记录的唯一性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E6%9C%80%E5%B0%91%E5%AD%98%E5%82%A8%E4%B8%A4%E6%9D%A1%E8%AE%B0%E5%BD%95"><span class="toc-number">1.4.3.</span> <span class="toc-text">一个页面最少存储两条记录</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB-%E4%B8%8E-MyISAM-%E7%B4%A2%E5%BC%95%E5%AF%B9%E6%AF%94"><span class="toc-number">1.5.</span> <span class="toc-text">InnoDB 与 MyISAM 索引对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AF%B9%E6%AF%94"><span class="toc-number">1.6.</span> <span class="toc-text">索引数据结构对比</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Hash"><span class="toc-number">1.6.1.</span> <span class="toc-text">Hash</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.6.2.</span> <span class="toc-text">二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AVL-%E6%A0%91"><span class="toc-number">1.6.3.</span> <span class="toc-text">AVL 树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-Tree"><span class="toc-number">1.6.4.</span> <span class="toc-text">B-Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-Tree-1"><span class="toc-number">1.6.5.</span> <span class="toc-text">B+Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-Tree-%E4%B8%8E-B-Tree-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.6.6.</span> <span class="toc-text">B-Tree 与 B+Tree 的区别？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%A1%B5%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.7.</span> <span class="toc-text">数据页内部结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86"><span class="toc-number">1.7.1.</span> <span class="toc-text">第一部分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#File-Header%EF%BC%88%E6%96%87%E4%BB%B6%E5%A4%B4%E9%83%A8%EF%BC%89%EF%BC%9A"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">File Header（文件头部）：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#File-Trailder%EF%BC%88%E6%96%87%E4%BB%B6%E5%B0%BE%E9%83%A8-8-%E5%AD%97%E8%8A%82%EF%BC%89%EF%BC%9A"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">File Trailder（文件尾部 8 字节）：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86"><span class="toc-number">1.7.2.</span> <span class="toc-text">第二部分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E5%92%8C%E7%94%A8%E6%88%B7%E8%AE%B0%E5%BD%95%EF%BC%88Free-Space-amp-User-Records%EF%BC%89"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">空闲空间和用户记录（Free Space &amp; User Records）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%9A%84%E8%AE%B0%E5%BD%95%E5%A4%B4%E4%BF%A1%E6%81%AF"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">记录行格式的记录头信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E6%9C%80%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%AE%B0%E5%BD%95%EF%BC%88Infimum-Supremum"><span class="toc-number">1.7.2.3.</span> <span class="toc-text">最小最大数据记录（Infimum + Supremum)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86"><span class="toc-number">1.7.3.</span> <span class="toc-text">第三部分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Page-Directory"><span class="toc-number">1.7.3.1.</span> <span class="toc-text">Page Directory</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Page-Header"><span class="toc-number">1.7.3.2.</span> <span class="toc-text">Page Header</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB-%E8%A1%8C%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.8.</span> <span class="toc-text">InnoDB 行格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Compact-%E8%A1%8C%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.8.1.</span> <span class="toc-text">Compact 行格式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%95%BF%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6%E5%88%97%E8%A1%A8"><span class="toc-number">1.8.1.1.</span> <span class="toc-text">变长字段长度列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NULL-%E5%80%BC%E5%88%97%E8%A1%A8"><span class="toc-number">1.8.1.2.</span> <span class="toc-text">NULL 值列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E5%A4%B4%E4%BF%A1%E6%81%AF"><span class="toc-number">1.8.1.3.</span> <span class="toc-text">记录头信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E7%9A%84%E7%9C%9F%E5%AE%9E%E6%95%B0%E6%8D%AE"><span class="toc-number">1.8.1.4.</span> <span class="toc-text">记录的真实数据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redundant-%E8%A1%8C%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.8.2.</span> <span class="toc-text">Redundant 行格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E6%BA%A2%E5%87%BA%E6%95%B0%E6%8D%AE"><span class="toc-number">1.8.3.</span> <span class="toc-text">行溢出数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dynamic-%E5%92%8C-Compressed-%E8%A1%8C%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.8.4.</span> <span class="toc-text">Dynamic 和 Compressed 行格式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E7%A9%BA%E9%97%B4%E3%80%81%E6%AE%B5%E3%80%81%E5%8C%BA"><span class="toc-number">1.9.</span> <span class="toc-text">表空间、段、区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%EF%BC%88extent%EF%BC%89"><span class="toc-number">1.9.1.</span> <span class="toc-text">区（extent）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">1.9.1.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.9.1.2.</span> <span class="toc-text">区的分类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AE%B5%EF%BC%88Segment%EF%BC%89"><span class="toc-number">1.10.</span> <span class="toc-text">段（Segment）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-number">1.11.</span> <span class="toc-text">创建索引的语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%A1%A8%E7%9A%84%E6%97%B6%E5%80%99%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">1.11.1.</span> <span class="toc-text">创建表的时候创建索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E5%B7%B2%E7%BB%8F%E5%AD%98%E5%9C%A8%E7%9A%84%E8%A1%A8%E4%B8%8A%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95"><span class="toc-number">1.11.2.</span> <span class="toc-text">在已经存在的表上建立索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95"><span class="toc-number">1.11.3.</span> <span class="toc-text">删除索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">1.12.</span> <span class="toc-text">索引的设计原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%B8%8B%E9%80%82%E5%90%88%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E4%BB%A5%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.12.1.</span> <span class="toc-text">哪些情况下适合创建索引以及注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E6%9C%89%E5%94%AF%E4%B8%80%E6%80%A7%E7%89%B9%E5%BE%81%E7%9A%84%E5%AD%97%E6%AE%B5"><span class="toc-number">1.12.1.1.</span> <span class="toc-text">具有唯一性特征的字段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%91%E7%B9%81%E4%BD%9C%E4%B8%BA%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%AD%97%E6%AE%B5"><span class="toc-number">1.12.1.2.</span> <span class="toc-text">频繁作为条件查询的字段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%8F%E5%B8%B8%E4%BD%9C%E4%B8%BA%E5%88%86%E7%BB%84%E5%92%8C%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AD%97%E6%AE%B5"><span class="toc-number">1.12.1.3.</span> <span class="toc-text">经常作为分组和排序的字段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#update%E3%80%81delete-%E7%9A%84-%E6%9D%A1%E4%BB%B6%E5%88%97"><span class="toc-number">1.12.1.4.</span> <span class="toc-text">update、delete 的 条件列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#distinct-%E5%88%97"><span class="toc-number">1.12.1.5.</span> <span class="toc-text">distinct 列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E8%A1%A8%E8%BF%9E%E6%8E%A5%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.12.1.6.</span> <span class="toc-text">多表连接创建索引的注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%88%97%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%B0%8F%E7%9A%84%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">1.12.1.7.</span> <span class="toc-text">使用列的类型小的创建索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%E5%89%8D%E7%BC%80%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">1.12.1.8.</span> <span class="toc-text">使用字符前缀创建索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8C%BA%E5%88%86%E5%BA%A6%EF%BC%88%E6%95%A3%E5%88%97%E5%BA%A6%EF%BC%89%E9%AB%98%E7%9A%84%E5%88%97%E4%BD%9C%E4%B8%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">1.12.1.9.</span> <span class="toc-text">使用区分度（散列度）高的列作为索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%A2%91%E7%B9%81%E7%9A%84%E5%88%97%E6%94%BE%E5%88%B0%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E7%9A%84%E5%B7%A6%E4%BE%A7%EF%BC%88%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E6%B3%95%E5%88%99%EF%BC%89"><span class="toc-number">1.12.1.10.</span> <span class="toc-text">使用频繁的列放到联合索引的左侧（最左前缀法则）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E5%AD%97%E6%AE%B5%E9%83%BD%E8%A6%81%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E4%BC%98%E4%BA%8E%E5%8D%95%E5%88%97%E7%B4%A2%E5%BC%95"><span class="toc-number">1.12.1.11.</span> <span class="toc-text">多个字段都要创建索引的情况下，联合索引优于单列索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%90%E5%88%B6%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E7%9B%AE"><span class="toc-number">1.12.1.12.</span> <span class="toc-text">限制索引的数目</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%B8%8B%E4%B8%8D%E9%80%82%E5%90%88%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">1.12.2.</span> <span class="toc-text">哪些情况下不适合创建索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%88%B0%E7%9A%84%E5%88%97%EF%BC%8C%E4%B8%8D%E8%A6%81%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">1.12.2.1.</span> <span class="toc-text">条件查询中使用不到的列，不要创建索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%87%8F%E5%B0%8F%E7%9A%84%E8%A1%A8%E4%B8%8D%E8%A6%81%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">1.12.2.2.</span> <span class="toc-text">数据量小的表不要创建索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E9%87%8F%E9%87%8D%E5%A4%8D%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%97%EF%BC%8C%E4%B8%8D%E8%A6%81%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">1.12.2.3.</span> <span class="toc-text">大量重复数据的列，不要创建索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E5%AF%B9%E7%BB%8F%E5%B8%B8%E6%9B%B4%E6%96%B0%E8%A1%A8%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95"><span class="toc-number">1.12.2.4.</span> <span class="toc-text">避免对经常更新表建立索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%E6%97%A0%E5%BA%8F%E7%9A%84%E5%80%BC%E4%BD%9C%E4%B8%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">1.12.2.5.</span> <span class="toc-text">不建议使用无序的值作为索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%BE%88%E5%B0%91%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B4%A2%E5%BC%95"><span class="toc-number">1.12.2.6.</span> <span class="toc-text">删除很少使用的索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E8%A6%81%E5%AE%9A%E4%B9%89%E5%86%97%E4%BD%99%E6%88%96%E9%87%8D%E5%A4%8D%E7%B4%A2%E5%BC%95"><span class="toc-number">1.12.2.7.</span> <span class="toc-text">不要定义冗余或重复索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.12.3.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Explan"><span class="toc-number">1.13.</span> <span class="toc-text">Explan</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#table"><span class="toc-number">1.13.1.</span> <span class="toc-text">table</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#id"><span class="toc-number">1.13.2.</span> <span class="toc-text">id</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="toc-number">1.13.2.1.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#select-type"><span class="toc-number">1.13.3.</span> <span class="toc-text">select_type</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#partitions"><span class="toc-number">1.13.4.</span> <span class="toc-text">partitions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#type%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">1.13.5.</span> <span class="toc-text">type（重要）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#system"><span class="toc-number">1.13.5.1.</span> <span class="toc-text">system</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#const"><span class="toc-number">1.13.5.2.</span> <span class="toc-text">const</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#eq-ref"><span class="toc-number">1.13.5.3.</span> <span class="toc-text">eq_ref</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ref"><span class="toc-number">1.13.5.4.</span> <span class="toc-text">ref</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fulltext"><span class="toc-number">1.13.5.5.</span> <span class="toc-text">fulltext</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ref-or-null"><span class="toc-number">1.13.5.6.</span> <span class="toc-text">ref_or_null</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#index-merge"><span class="toc-number">1.13.5.7.</span> <span class="toc-text">index_merge</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unique-subquery"><span class="toc-number">1.13.5.8.</span> <span class="toc-text">unique_subquery</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#index-subquery"><span class="toc-number">1.13.5.9.</span> <span class="toc-text">index_subquery</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#range"><span class="toc-number">1.13.5.10.</span> <span class="toc-text">range</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#index"><span class="toc-number">1.13.5.11.</span> <span class="toc-text">index</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#all"><span class="toc-number">1.13.5.12.</span> <span class="toc-text">all</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-2"><span class="toc-number">1.13.5.13.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#possible-keys-%E5%92%8C-key"><span class="toc-number">1.13.6.</span> <span class="toc-text">possible_keys 和 key</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#key-len%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">1.13.7.</span> <span class="toc-text">key_len（重要）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ref-1"><span class="toc-number">1.13.8.</span> <span class="toc-text">ref</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rows%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">1.13.9.</span> <span class="toc-text">rows（重要）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#filtered"><span class="toc-number">1.13.10.</span> <span class="toc-text">filtered</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Extra"><span class="toc-number">1.13.11.</span> <span class="toc-text">Extra</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JSON-%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%9A%84-Explan"><span class="toc-number">1.13.12.</span> <span class="toc-text">JSON 格式化的 Explan</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E4%B8%8E%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-number">1.14.</span> <span class="toc-text">索引优化与查询优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9C%80%E4%BD%B3%E5%9C%BA%E6%99%AF%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.14.1.</span> <span class="toc-text">使用索引的最佳场景和注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%9C%BA%E6%99%AF"><span class="toc-number">1.14.1.0.1.</span> <span class="toc-text">最佳场景</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.14.1.0.2.</span> <span class="toc-text">注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-number">1.14.2.</span> <span class="toc-text">索引失效的场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E6%B3%95%E5%88%99"><span class="toc-number">1.14.2.1.</span> <span class="toc-text">最左前缀法则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E3%80%81%E5%87%BD%E6%95%B0%E3%80%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.14.2.2.</span> <span class="toc-text">计算、函数、类型转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8C%83%E5%9B%B4%E6%9D%A1%E4%BB%B6%E5%8F%B3%E8%BE%B9%E7%9A%84%E7%B4%A2%E5%BC%95%E5%88%97"><span class="toc-number">1.14.2.3.</span> <span class="toc-text">范围条件右边的索引列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E7%AD%89%E4%BA%8E%E6%9D%A1%E4%BB%B6%EF%BC%88-%E6%88%96-lt-gt-%EF%BC%89"><span class="toc-number">1.14.2.4.</span> <span class="toc-text">不等于条件（!&#x3D; 或 &lt;&gt;）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#is-not-null-%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95"><span class="toc-number">1.14.2.5.</span> <span class="toc-text">is not null 无法使用索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#like-%E4%BB%A5%E9%80%9A%E9%85%8D%E7%AC%A6-%E5%BC%80%E5%A4%B4"><span class="toc-number">1.14.2.6.</span> <span class="toc-text">like 以通配符 % 开头</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#or-%E5%89%8D%E5%90%8E%E5%AD%98%E5%9C%A8%E9%9D%9E%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%97"><span class="toc-number">1.14.2.7.</span> <span class="toc-text">or 前后存在非索引的列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E5%AD%97%E7%AC%A6%E9%9B%86%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.14.2.8.</span> <span class="toc-text">不同字符集的转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96-1"><span class="toc-number">1.14.3.</span> <span class="toc-text">查询优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.14.3.1.</span> <span class="toc-text">连接查询</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%E5%8E%9F%E7%90%86"><span class="toc-number">1.14.3.1.1.</span> <span class="toc-text">连接查询原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B7%A6%E5%8F%B3%E5%A4%96%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.14.3.1.2.</span> <span class="toc-text">左右外连接</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.14.3.1.3.</span> <span class="toc-text">内连接</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%E5%B0%8F%E7%BB%93"><span class="toc-number">1.14.3.1.4.</span> <span class="toc-text">连接查询小结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-number">1.14.3.2.</span> <span class="toc-text">子查询优化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%90%E6%9F%A5%E8%AF%A2%E5%8E%9F%E7%90%86"><span class="toc-number">1.14.3.2.1.</span> <span class="toc-text">子查询原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5"><span class="toc-number">1.14.3.2.2.</span> <span class="toc-text">优化策略</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96"><span class="toc-number">1.14.3.3.</span> <span class="toc-text">排序优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GROUP-BY-%E4%BC%98%E5%8C%96"><span class="toc-number">1.14.3.4.</span> <span class="toc-text">GROUP BY 优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.14.3.5.</span> <span class="toc-text">优化分页查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E8%80%83%E8%99%91%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-number">1.14.3.6.</span> <span class="toc-text">优先考虑覆盖索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8"><span class="toc-number">1.14.3.7.</span> <span class="toc-text">索引下推</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95-VS-%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95"><span class="toc-number">1.14.3.8.</span> <span class="toc-text">普通索引 VS 唯一索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5"><span class="toc-number">1.14.3.9.</span> <span class="toc-text">其他查询优化策略</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">2.</span> <span class="toc-text">参考资料</span></a></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-MySQL/mysql-进阶" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      MySQL 进阶
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2023/05/19/MySQL/mysql-%E8%BF%9B%E9%98%B6/" class="article-date">
	  <time datetime="2023-05-18T22:46:09.342Z" itemprop="datePublished">2023-05-19</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/MySQL/">MySQL</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link-link" href="/tags/MySQL/" rel="tag">MySQL</a>
  </span>


        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill" aria-hidden="true"></i>
	    <span id="busuanzi_container_page_pv">
			<span id="busuanzi_value_page_pv">0</span>
		</span>
	</span>


        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2023/05/19/MySQL/mysql-%E8%BF%9B%E9%98%B6/#comments" class="article-comment-link">评论</a></span>
        
      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="MySQL-进阶"><a href="#MySQL-进阶" class="headerlink" title="MySQL 进阶"></a>MySQL 进阶</h1><h2 id="MySQL-架构"><a href="#MySQL-架构" class="headerlink" title="MySQL 架构"></a>MySQL 架构</h2><p>如图所示，MySQL </p>
<p>架构分为三层</p>
<ol>
<li>连接层</li>
<li>服务层（解析与优化）</li>
<li>存储引擎层    </li>
</ol>
<p><img src="/../../image/mysql-%E8%BF%9B%E9%98%B6.assets/image-20230401093434378.png" alt="image-20230401093434378"></p>
<p>引用于《MySQL 是怎样运行的：从根儿上理解 MySQL》</p>
<h3 id="连接层"><a href="#连接层" class="headerlink" title="连接层"></a>连接层</h3><ol>
<li>客户端发起连接请求时，连接层会验证客户端携带的主机名，用户名和密码是否正确。</li>
<li>建立连接后，会验证客户端是否拥有操作数据库的权限。</li>
</ol>
<h3 id="服务层"><a href="#服务层" class="headerlink" title="服务层"></a>服务层</h3><h4 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h4><ul>
<li>一条查询语句进入服务层后，会先进行查询缓存，如果缓存中已经有该查询的语句，则直接返回结果，无需再走语法解析、查询优化等流程。</li>
<li>缓存是 key-value 形式存储的。key 为 SQL 语句，value 为结果集。两条 SQL 语义完全相同，但其中一条 SQL 仅仅只是多了个空格，SQL 都不会命中。</li>
<li>当表中的数据发生了增、删、改等更新的操作，该表的缓存就会被删除。 </li>
<li>MySQL 的缓存命中率非常低，SQL 语句中也会包含一些函数处理，如日期时间 now() ，每次的时间都不一样，自然也不会命中缓存。</li>
<li>从MySQL 5.7.20 开始，不推荐使用查询缓存，需要手动开启，MySQL 8.0 中删除查询缓存。</li>
</ul>
<h4 id="语法解析"><a href="#语法解析" class="headerlink" title="语法解析"></a>语法解析</h4><p>​    当没有命中缓存，就会进入到语法解析阶段，分析器会对 SQL 语句进行词法、语法分析，如果你的 SQL 不满足 MySQL 的语法要求，就会报错提醒你的 SQL 语句异常。</p>
<h4 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h4><p>​    语法解析后，MySQL 会对 SQL 语句进行查询优化，如选择要使用的索引，连接表的顺序，子查询转为连接等。最终会生成一个执行计划。</p>
<h3 id="存储引擎层"><a href="#存储引擎层" class="headerlink" title="存储引擎层"></a>存储引擎层</h3><p>​    SQL 优化完成后，就进行了执行阶段，此时会通过 MySQL 的存储引擎对数据表进行存取操作。存储引擎是可拔插的，常见的存储引擎有 InnoDB，MyISAM 等。</p>
<h3 id="SQL-执行流程"><a href="#SQL-执行流程" class="headerlink" title="SQL 执行流程"></a>SQL 执行流程</h3><p>一条 SQL 的完整执行流程如下：</p>
<p><img src="/../../image/mysql-%E8%BF%9B%E9%98%B6.assets/image-20230401124842469.png" alt="image-20230401124842469"></p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h3><p>索引，类似一本书的目录，用来快速检索数据的一种数据结构。</p>
<h3 id="索引的优缺点？"><a href="#索引的优缺点？" class="headerlink" title="索引的优缺点？"></a>索引的优缺点？</h3><p><strong>优点：</strong></p>
<ol>
<li>可以加快对数据的检索速度，减少磁盘的 IO 次数</li>
<li>唯一索引可以保证数据的唯一性。</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>创建和维护索引需要耗费时间，会降低增删改的效率。</li>
<li>索引也会占用磁盘空间。</li>
</ol>
<h3 id="没有索引的查找方式"><a href="#没有索引的查找方式" class="headerlink" title="没有索引的查找方式"></a>没有索引的查找方式</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> name <span class="operator">=</span> xxx</span><br></pre></td></tr></table></figure>

<p>以这个精确查询为例，假设 name 列没有索引，那么 MySQL 会进行<strong>全表扫描</strong>，也就是一个一个的去匹配，对整张表所有记录都匹配个遍。可见，<strong>全表扫描</strong>的效率是非常低的，因此索引应运而生。</p>
<h3 id="索引的设计方案"><a href="#索引的设计方案" class="headerlink" title="索引的设计方案"></a>索引的设计方案</h3><h3 id="Comcact-行格式"><a href="#Comcact-行格式" class="headerlink" title="Comcact 行格式"></a>Comcact 行格式</h3><ul>
<li><p>record_type：记录头信息的一项属性，表示记录的类型。</p>
<ul>
<li> 0：表示普通记录</li>
<li> 1 ：表示目录项</li>
<li> 2： 表示最小记录</li>
<li> 3： 表示最大记录</li>
</ul>
</li>
<li><p>next_record：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，我们用</p>
<p>箭头来表明下一条记录是谁。</p>
</li>
<li><p>各个列的值：这里只记录在 index_demo 表中的三个列，分别是 c1 、 c2 和 c3 。</p>
</li>
<li><p>其他信息：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。</p>
</li>
</ul>
<p>Comcact 行格式简化示意图：</p>
<p><img src="/../../image/mysql-%E8%BF%9B%E9%98%B6.assets/image-20230405212706534.png" alt="image-20230405212706534"></p>
<p>把记录放到页里的示意图：</p>
<p><img src="/../../image/mysql-%E8%BF%9B%E9%98%B6.assets/image-20230406204525186.png" alt="image-20230406204525186">    </p>
<h3 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h3><h4 id="B-树"><a href="#B-树" class="headerlink" title="B+ 树"></a>B+ 树</h4><p>InnoDB 和 MyISAM 默认使用的索引数据结构都是 B+ 树。record_type = 0 的，表示存储的是用户的记录，通常称为 <strong>叶子节点</strong>；record_type = 1的，表示存储的是目录项，通常称为 <strong>内节点</strong> 或 <strong>非叶子节点</strong></p>
<p>在 MySQL 中，一颗简化的 B+ 树示意图如下（聚簇索引的结构）：</p>
<p><img src="/../../image/mysql-%E8%BF%9B%E9%98%B6.assets/image-20230406210455128.png" alt="image-20230406210455128">    </p>
<p>从此图中可以发现 B+ 树的几种特点：</p>
<ul>
<li>内节点记录了每一页索引列的最小值和页号，为了方便 B+ 树使用二分法进行检索。</li>
<li><strong>页内</strong> 的记录是按照主键的大小顺序排成了一个 <strong>单向链表</strong>。</li>
<li>各个层级的 <strong>页</strong>，也是根据主键的大小顺序排序成了一个 <strong>双向链表</strong></li>
<li><strong>叶子节点存储了用户的完整记录</strong>（聚簇索引，完整的记录指存储了所有的列的值)。<strong>如果是非聚簇索引，叶子节点只存储了主键和索引列的值。</strong></li>
</ul>
<h2 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h2><p>按照物理实现方式，索引分为聚簇索引和非聚簇索引。</p>
<h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p>一般一张表中都会有一个主键，InnoDB 会为主键建立一个聚簇索引。如果表中没有主键，InnoDB 会自动为我们选择一个列作为聚簇索引。我们上面 B+ 树的图，其实就是聚簇索引的索引结构。</p>
<p>聚簇索引的<strong>特点</strong>：</p>
<ul>
<li>叶子节点存储的完整的记录。</li>
<li>页内存储的记录按照主键的大小顺序排成一个 <strong>单向链表</strong>。</li>
<li>各个层级的页，是按照主键的大小顺序排成一个 <strong>双向链表</strong>。</li>
<li>由于叶子节点存储了完整的记录，所以聚簇不需要回表查询，<strong>检索效率很高</strong>。</li>
</ul>
<h3 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h3><p>二级索引又被称为 <strong>非聚簇索引</strong> 或 <strong>辅助索引</strong> </p>
<ul>
<li><strong>叶子节点</strong> 存储的是 **索引列+主键 **的组合，并不是一条完整的记录。</li>
<li>由于 <strong>叶子节点</strong> 只存储了 <strong>索引列+主键</strong>，因此还需要通过主键在聚簇索引中 **回表查询 **一次（一共查询两颗索引树）。</li>
</ul>
<h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p>联合索引也是二级索引的一种，只不过联合索引是多列组合成一个索引，例如：<strong>列1+列2+主键</strong> 的组合（叶子节点）。</p>
<h2 id="InnoDB-的-B-树索引的注意事项"><a href="#InnoDB-的-B-树索引的注意事项" class="headerlink" title="InnoDB 的 B+ 树索引的注意事项"></a>InnoDB 的 B+ 树索引的注意事项</h2><h3 id="根页面万年不动窝"><a href="#根页面万年不动窝" class="headerlink" title="根页面万年不动窝"></a>根页面万年不动窝</h3><p>一个B+树索引的根节点自诞生之日起，便不会再移动</p>
<h3 id="内节点中目录项记录的唯一性"><a href="#内节点中目录项记录的唯一性" class="headerlink" title="内节点中目录项记录的唯一性"></a>内节点中目录项记录的唯一性</h3><p>我们需要保证在B+树的同一层内节点的目录项记录除 页号 这个字段以外是唯一的。所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的：</p>
<ol>
<li>索引列的值</li>
<li>主键值</li>
<li>页号</li>
</ol>
<h3 id="一个页面最少存储两条记录"><a href="#一个页面最少存储两条记录" class="headerlink" title="一个页面最少存储两条记录"></a>一个页面最少存储两条记录</h3><h2 id="InnoDB-与-MyISAM-索引对比"><a href="#InnoDB-与-MyISAM-索引对比" class="headerlink" title="InnoDB 与 MyISAM 索引对比"></a>InnoDB 与 MyISAM 索引对比</h2><ol>
<li>InnoDB 索引即数据，索引和数据存放在一个文件中；MyISAM 数据和索引分离，放在不同的文件中。</li>
<li>InnoDB 必须有一个主键，也就是说必须有一个聚簇索引；MyISAM 可以没有主键，所有索引都是二级索引。</li>
<li>InnoDB 回表是通过主键进行回表查询，MyISAM 是通过值的地址进行回表查询，MyISAM 回表速度更快。</li>
</ol>
<h2 id="索引数据结构对比"><a href="#索引数据结构对比" class="headerlink" title="索引数据结构对比"></a>索引数据结构对比</h2><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>可以使相同的输入得到相同的输出，效率极高。但有可能发生 Hash 碰撞，可以用链表法来解决，将散列到同一槽位的元素放在一个链表中。 </p>
<p><strong>优点：</strong>查询效率极高，<strong>O(1)</strong> 复杂度</p>
<p><strong>缺点：</strong></p>
<ul>
<li>不支持范围查询</li>
<li>InnoDB 不支持 Hash</li>
</ul>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>使用二分法进行搜索，降低<strong>磁盘 IO</strong> 次数，但有可能退化为链表。</p>
<p><strong>优点：</strong>范围查询，使用二分法搜索有效减少了<strong>磁盘 IO</strong> 次数</p>
<p><strong>缺点：</strong>当插入的数据是有序的，二叉树有可能会退化为一个链表</p>
<h3 id="AVL-树"><a href="#AVL-树" class="headerlink" title="AVL 树"></a>AVL 树</h3><p>平衡二叉树，可以自平衡的二叉树。</p>
<h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h3><p>B 树，叶子节点和非叶子节点都会存储数据</p>
<h3 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h3><p>B+ 树，只有叶子节点才会存储数据。</p>
<h3 id="B-Tree-与-B-Tree-的区别？"><a href="#B-Tree-与-B-Tree-的区别？" class="headerlink" title="B-Tree 与 B+Tree 的区别？"></a>B-Tree 与 B+Tree 的区别？</h3><ul>
<li>B+ 树叶子节点才会存储数据，B 树叶子节点和非叶子节点都会存储数据。</li>
<li>B+ 树索引次数相对稳定，B 树可能会在非叶子节点终止搜索。</li>
</ul>
<h2 id="数据页内部结构"><a href="#数据页内部结构" class="headerlink" title="数据页内部结构"></a>数据页内部结构</h2><p>数据的页的大小为 16kb，磁盘和内存交互的基本单位就是页，B+ 树中同一层级的页是形成了一个双向链表，这个链表不是物理上连续的，而是逻辑上连续的。</p>
<p>页的内部结构 7 个部分：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>中文名</th>
<th>占用空间大小</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>File Header</td>
<td>文件头部</td>
<td>38 字节</td>
<td>页的一些通用信息</td>
</tr>
<tr>
<td>Page Header</td>
<td>页面头部</td>
<td>56 字节</td>
<td>数据页专有的一些信息</td>
</tr>
<tr>
<td>Infomum + Supremum</td>
<td>最小记录和最大记录</td>
<td>26 字节</td>
<td>两个虚拟的行记录</td>
</tr>
<tr>
<td>User Records</td>
<td>用户记录</td>
<td>不确定</td>
<td>实际存储的行记录内容</td>
</tr>
<tr>
<td>Free Space</td>
<td>空闲空间</td>
<td>不确定</td>
<td>页中尚未使用的空间</td>
</tr>
<tr>
<td>Page Directory</td>
<td>页面目录</td>
<td>不确定</td>
<td>页中某些记录的相对位置</td>
</tr>
<tr>
<td>File Trailer</td>
<td>文件尾部</td>
<td>8 字节</td>
<td>校验页是否完整</td>
</tr>
</tbody></table>
<p>​    <img src="/../../image/mysql-%E8%BF%9B%E9%98%B6.assets/image-20230411181138105.png" alt="image-20230411181138105"></p>
<h3 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h3><h4 id="File-Header（文件头部）："><a href="#File-Header（文件头部）：" class="headerlink" title="File Header（文件头部）："></a>File Header（文件头部）：</h4><p>主要记录了页的通用信息：</p>
<p><img src="/mysql-%E8%BF%9B%E9%98%B6.assets/image-20230412003347844.png" alt="image-20230412003347844"></p>
<ul>
<li>FIL_PAGE_OFFSET（页号）：好比身份证号码一样，InnoDB 可以通过页号 <strong>唯一定位</strong> 一个页</li>
<li>FIL_PAGE_TYPE（页类型）： 如 Undo 日志页、系统页、索引页等</li>
<li>FIL_PAGE_PREV，FIL_PAGE_NEXT（上一个页的页号，下一个页的页号）：页号在磁盘上无法保证是连续空间，通过这两个字段将页串联起来，形成一个双向链表，从而实现逻辑上是连续的。</li>
<li>FIL_PAGE_SPACE_OR_CHKSUM（校验和）：将数据从内存中刷到磁盘中时，可能会发生断电等意外情况，校验和的作用就是校验刷盘前和刷盘后，数据是否一致。校验和能够保证数据的完整性和一致性。</li>
<li>FIL_PAGE_LSN：页面被最后修改时对应的日志序列位置</li>
</ul>
<h4 id="File-Trailder（文件尾部-8-字节）："><a href="#File-Trailder（文件尾部-8-字节）：" class="headerlink" title="File Trailder（文件尾部 8 字节）："></a>File Trailder（文件尾部 8 字节）：</h4><ul>
<li>前 4 个字节代表页的校验和，与文件头部的校验和对应。</li>
<li>后 4 个字节代表页面被最后修改时对应的日志序列位置（LSN），为了校验页的完整性。</li>
</ul>
<h3 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h3><h4 id="空闲空间和用户记录（Free-Space-amp-User-Records）"><a href="#空闲空间和用户记录（Free-Space-amp-User-Records）" class="headerlink" title="空闲空间和用户记录（Free Space &amp; User Records）"></a>空闲空间和用户记录（Free Space &amp; User Records）</h4><p>通常我们说用户的数据存放在数据页的用户记录部分中（User Records），但其实刚生成的页并没有用户记录这一部分；每次插入新的数据，其实会从空闲空间（Free Space）中划出一部分空间给用户记录部分，等到空闲空间全部用完了，都划分给用户记录部分了，就代表需要新开一个数据页来存储数据了。</p>
<p><strong>用户记录部分的数据会形成一个单向链表，它们是按照主键的大小顺序进行排放的。</strong></p>
<p><img src="/../../image/mysql-%E8%BF%9B%E9%98%B6.assets/image-20230412230901365.png" alt="image-20230412230901365">        </p>
<h4 id="记录行格式的记录头信息"><a href="#记录行格式的记录头信息" class="headerlink" title="记录行格式的记录头信息"></a>记录行格式的记录头信息</h4><p>详见 Compact 行格式的记录头信息</p>
<h4 id="最小最大数据记录（Infimum-Supremum"><a href="#最小最大数据记录（Infimum-Supremum" class="headerlink" title="最小最大数据记录（Infimum + Supremum)"></a>最小最大数据记录（Infimum + Supremum)</h4><p>用于比较记录的大小，也就是比较主键的大小；它们不存放在 Records 中，它们独立存放在一个称为 Infimum + Supremum 的部分。</p>
<h3 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a>第三部分</h3><h4 id="Page-Directory"><a href="#Page-Directory" class="headerlink" title="Page Directory"></a>Page Directory</h4><p>在页中，用户的记录是一个单向链表，插入效率高，但检索的效率并不高。<strong>为了提高检索速度，专门给用户记录做一个目录（也就是页目录），通过二分查找法的方式进行检索，提升效率。</strong></p>
<p>页目录将用户数据分成多个小组，将每个分组的最大记录放入到页目录中一个个的槽位（Slot）中。</p>
<p>分组的规则是：</p>
<ul>
<li>最小的记录单独为一组，只能存放 1 条记录</li>
<li>最大的记录的分组可以存放 1~8 条记录</li>
<li>其他的分组可以存放 4~8 条记录</li>
</ul>
<p>每个组的<strong>最后一条记录（也就是组内最大的那条记录</strong>）的<strong>头信息中的 n_owned 属性表示该组内共有几条记录</strong>。</p>
<p><img src="/../../image/mysql-%E8%BF%9B%E9%98%B6.assets/image-20230412232619116.png" alt="image-20230412232619116"></p>
<p>所以在一个数据页中查找指定主键值的记录的过程分为两步：</p>
<ol>
<li>通过二分法确定该记录所在的槽，并找到该槽中主键值最小的那条记录。</li>
<li>通过记录的 next_record 属性遍历该槽所在的组中的各个记录。</li>
</ol>
<h4 id="Page-Header"><a href="#Page-Header" class="headerlink" title="Page Header"></a>Page Header</h4><p>数据页中存储的记录的状态信息</p>
<p><img src="/../../image/mysql-%E8%BF%9B%E9%98%B6.assets/image-20230412003226986.png" alt="image-20230412003226986"></p>
<h2 id="InnoDB-行格式"><a href="#InnoDB-行格式" class="headerlink" title="InnoDB 行格式"></a>InnoDB 行格式</h2><h3 id="Compact-行格式"><a href="#Compact-行格式" class="headerlink" title="Compact 行格式"></a>Compact 行格式</h3><p>Compact 行格式示意图：</p>
<p><img src="/../../image/mysql-%E8%BF%9B%E9%98%B6.assets/image-20230413231430770.png" alt="image-20230413231430770"></p>
<h4 id="变长字段长度列表"><a href="#变长字段长度列表" class="headerlink" title="变长字段长度列表"></a>变长字段长度列表</h4><p>​    用来存储 VARCHAR()、VARBINARY()、TEXT 等这种长度不固定的数据类型，并且存储它们的字节长度。把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表，各变长字段数据占用的字节数按照列的顺序 <strong>逆序</strong> 存放，比如两个varchar字段在表结构的顺序是a(10)，b(15)。那么在变长字段长度列表中存储的长度顺序就是15，10。</p>
<h4 id="NULL-值列表"><a href="#NULL-值列表" class="headerlink" title="NULL 值列表"></a>NULL 值列表</h4><p>存放所有列的 NULL 值，如果把这些 NULL 值都放到记录的真实数据中存储会很占地方，所以专门创建了一个 NULL 值列表来管理。如果表中没有允许存储 <strong>NULL</strong> 的列，则 NULL 值列表 也不存在了。</p>
<h4 id="记录头信息"><a href="#记录头信息" class="headerlink" title="记录头信息"></a>记录头信息</h4><p>记录头信息中的 next_record 是用户记录中的数据形成一个单向链表的关键，但 <strong>next_record 记录是下一条数据的地址偏移量</strong>。下一条记录也不是按照插入顺序的下一条，而是<strong>按照主键大小顺序排列的下一条数据</strong>。而且规定 <strong>Infimum</strong>记录（也就是最小记录） 的下一条记录就是本页中主键值最小的用户记录，而本页中主键值最大的用户记录的下一条记录就是 <strong>Supremum</strong>记录（也就是最大记录）</p>
<p>记录头的各个属性：</p>
<p><img src="/../../image/mysql-%E8%BF%9B%E9%98%B6.assets/image-20230412234130085.png" alt="image-20230412234130085"></p>
<p>记录头信息示意图：</p>
<p><img src="/../../image/mysql-%E8%BF%9B%E9%98%B6.assets/image-20230412233911129.png" alt="image-20230412233911129">记录头信息在用户记录中的示意图：</p>
<p><img src="/../../image/mysql-%E8%BF%9B%E9%98%B6.assets/image-20230412234005160.png" alt="image-20230412234005160"></p>
<p>引用于《MySQL 是怎样运行的：从根儿上理解 MySQL》</p>
<h4 id="记录的真实数据"><a href="#记录的真实数据" class="headerlink" title="记录的真实数据"></a>记录的真实数据</h4><p>MySQL 会为每个记录默认的添加一些列（也称为 隐藏列 ），具体的列如下：</p>
<p><img src="/../../image/mysql-%E8%BF%9B%E9%98%B6.assets/image-20230413233100799.png" alt="image-20230413233100799"></p>
<p>InnoDB 表对主键的生成策略：优先使用用户自定义主键作为主键，如果用户没有定义主键，则选取一个 Unique 键作为主键，如果表中连 Unique 键都没有定义的话，则 InnoDB 会为表默认添加一个名为row_id 的隐藏列作为主键。</p>
<p>所以我们从上表中可以看出：InnoDB存储引擎会为每条记录都添加 <strong>transaction_id</strong>和 <strong>roll_pointer</strong> 这两个列，但是 <strong>row_id</strong> 是可选的（在没有自定义主键以及Unique键的情况下才会添加该列）。这些隐藏列的值不用我们操心， InnoDB 存储引擎会自己帮我们生成的。</p>
<p>引用于《MySQL 是怎样运行的：从根儿上理解 MySQL》</p>
<h3 id="Redundant-行格式"><a href="#Redundant-行格式" class="headerlink" title="Redundant 行格式"></a>Redundant 行格式</h3><p><img src="/../../image/mysql-%E8%BF%9B%E9%98%B6.assets/image-20230413233433058.png" alt="image-20230413233433058"></p>
<p>注意 Compact 行格式的开头是 变长字段长度列表 ，而 Redundant 行格式的开头是 字段长度偏移列表 ，与</p>
<p>变长字段长度列表 有两处不同：</p>
<ul>
<li><p>没有了变长两个字，意味着 Redundant 行格式会把该条记录中所有列（包括 隐藏列 ）的长度信息都按照逆序存储到 字段长度偏移列表 。</p>
</li>
<li><p>多了个偏移两个字，这意味着计算列值长度的方式不像 Compact 行格式那么直观，它是采用两个相邻数值的差值来计算各个列值的长度。</p>
</li>
</ul>
<p>Redundant 没有 NULL 值列表，因此对 ULL 值的处理也是与 Compact 不同的。</p>
<ul>
<li>如果存储 NULL 值的字段类型是定长型的，如 CHAR，则 NULL 值也会占用记录的真实数据部分。</li>
<li>如果存储 NULL 值的字段类型是变长型的，如 VARCHAR，则 NULL 值不会占用记录的真实数据部分。</li>
</ul>
<h3 id="行溢出数据"><a href="#行溢出数据" class="headerlink" title="行溢出数据"></a>行溢出数据</h3><p>我们可以知道一个页的大小一般是16KB，也就是16384字节，而一个VARCHAR(M)类型的列就最多可以存储65533个字节，这样就可能出现一个页存放不了一条记录，这种现象称为行溢出。 </p>
<h3 id="Dynamic-和-Compressed-行格式"><a href="#Dynamic-和-Compressed-行格式" class="headerlink" title="Dynamic 和 Compressed 行格式"></a>Dynamic 和 Compressed 行格式</h3><p>在 MySQL 8.0 中，默认行格式就是 Dynamic，Dynamic、Compressed 行格式和 Compact 行格式挺像，只不过在处理行溢出数据时有分歧：</p>
<ul>
<li>Compressed 和 Dynamic 两种记录格式对于存放在 BLOB 中的数据采用了完全的行溢出的方式。如图，在数据页中只存放 20 个字节的指针（溢出页的地址），实际的数据都存放在 Off Page（溢出页）中。</li>
<li>Compact 和 Redundant 两种格式会在记录的真实数据处存储一部分数据（存放 768 个前缀字节）。</li>
</ul>
<p>Compressed 行记录格式的另一个功能就是，存储在其中的行数据会以 zlib 的算法进行压缩，因此对于 BLOB、TEXT、VARCHAR 这类大长度类型的数据能够进行非常有效的存储。<img src="/../../image/mysql-%E8%BF%9B%E9%98%B6.assets/image-20230413235212693.png" alt="image-20230413235212693">        </p>
<h2 id="表空间、段、区"><a href="#表空间、段、区" class="headerlink" title="表空间、段、区"></a>表空间、段、区</h2><h3 id="区（extent）"><a href="#区（extent）" class="headerlink" title="区（extent）"></a>区（extent）</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>连续的 64 个页就是一个区，也就是 1M ，每 256 个区被划分为一组。</p>
<h4 id="区的分类"><a href="#区的分类" class="headerlink" title="区的分类"></a>区的分类</h4><ul>
<li>空闲的区：现在还没有用到这个区中的任何页面。有剩余空间的碎片区：表示碎片区中还有可用的页面。</li>
<li>没有剩余空间的碎片区：表示碎片区中的所有页面都被使用，没有空闲页面。</li>
<li>附属于某个段的区。每一个索引都可以分为叶子节点段和非叶子节点段，除此之外InnoDB还会另外定义一些</li>
<li>特殊作用的段，在这些段中的数据量很大时将使用区来作为基本的分配单位。</li>
</ul>
<h2 id="段（Segment）"><a href="#段（Segment）" class="headerlink" title="段（Segment）"></a>段（Segment）</h2><ul>
<li>一个索引会产生两个段，分别是叶子节点段和非叶子节点段</li>
<li>回滚段</li>
</ul>
<h2 id="创建索引的语法"><a href="#创建索引的语法" class="headerlink" title="创建索引的语法"></a>创建索引的语法</h2><h3 id="创建表的时候创建索引"><a href="#创建表的时候创建索引" class="headerlink" title="创建表的时候创建索引"></a>创建表的时候创建索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name [col_name data_type]</span><br><span class="line">[<span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT <span class="operator">|</span> SPATIAL] [INDEX <span class="operator">|</span> KEY] [index_name] (col_name [length]) [<span class="keyword">ASC</span> <span class="operator">|</span></span><br><span class="line"><span class="keyword">DESC</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>UNIQUE 、 FULLTEXT 和 SPATIAL 为可选参数，分别表示唯一索引、全文索引和空间索引；</li>
<li>INDEX 与 KEY 为同义词，两者的作用相同，用来指定创建索引；</li>
<li>index_name 指定索引的名称，为可选参数，如果不指定，那么MySQL默认col_name为索引名；</li>
<li>col_name 为需要创建索引的字段列，该列必须从数据表中定义的多个列中选择；</li>
<li>length 为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度；</li>
<li>ASC 或 DESC 指定升序或者降序的索引值存储。</li>
</ul>
<h3 id="在已经存在的表上建立索引"><a href="#在已经存在的表上建立索引" class="headerlink" title="在已经存在的表上建立索引"></a>在已经存在的表上建立索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> [<span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT <span class="operator">|</span> SPATIAL] [INDEX <span class="operator">|</span> KEY]</span><br><span class="line">[index_name] (col_name[length],...) [<span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>]</span><br></pre></td></tr></table></figure>

<h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- ALTER 删除索引</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">DROP</span> INDEX index_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- DROP 删除索引</span></span><br><span class="line"><span class="keyword">DROP</span> INDEX index_name <span class="keyword">ON</span> table_name;</span><br></pre></td></tr></table></figure>

<h2 id="索引的设计原则"><a href="#索引的设计原则" class="headerlink" title="索引的设计原则"></a>索引的设计原则</h2><h3 id="哪些情况下适合创建索引以及注意事项"><a href="#哪些情况下适合创建索引以及注意事项" class="headerlink" title="哪些情况下适合创建索引以及注意事项"></a>哪些情况下适合创建索引以及注意事项</h3><h4 id="具有唯一性特征的字段"><a href="#具有唯一性特征的字段" class="headerlink" title="具有唯一性特征的字段"></a>具有唯一性特征的字段</h4><blockquote>
<p>业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。（来源：Alibaba）</p>
<p>说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的。</p>
</blockquote>
<h4 id="频繁作为条件查询的字段"><a href="#频繁作为条件查询的字段" class="headerlink" title="频繁作为条件查询的字段"></a>频繁作为条件查询的字段</h4><p>如果某个字段经常在 Where 条件中出现，那么可以考虑为这个字段创建索引。</p>
<h4 id="经常作为分组和排序的字段"><a href="#经常作为分组和排序的字段" class="headerlink" title="经常作为分组和排序的字段"></a>经常作为分组和排序的字段</h4><p>如果某个字段经常在 Group By 或 Order By条件中出现，那么可以考虑为这个字段创建索引。如果排序的列有多个，那么可以建立组合索引。</p>
<h4 id="update、delete-的-条件列"><a href="#update、delete-的-条件列" class="headerlink" title="update、delete 的 条件列"></a>update、delete 的 条件列</h4><p>对数据按照某个条件进行查询后再进行 UPDATE 或 DELETE 的操作，如果对 WHERE 字段创建了索引，就</p>
<p>能大幅提升效率。原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或</p>
<p>删除。<strong>如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。</strong></p>
<h4 id="distinct-列"><a href="#distinct-列" class="headerlink" title="distinct 列"></a>distinct 列</h4><p>对某个字段需要去重，使用 distinct，在这个字段上建立索引，也会提升查询效率。</p>
<h4 id="多表连接创建索引的注意事项"><a href="#多表连接创建索引的注意事项" class="headerlink" title="多表连接创建索引的注意事项"></a>多表连接创建索引的注意事项</h4><p>首先， 连接表的数量尽量不要超过 3 张 ，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增</p>
<p>长会非常快，严重影响查询的效率。</p>
<p>其次， 对 WHERE 条件创建索引 ，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下，</p>
<p>没有 WHERE 条件过滤是非常可怕的。</p>
<p>最后， 对用于连接的字段创建索引 ，并且该字段在多张表中的 类型必须一致 。比如 course_id 在</p>
<p>student_info 表和 course 表中都为 int(11) 类型，而不能一个为 int 另一个为 varchar 类型。</p>
<h4 id="使用列的类型小的创建索引"><a href="#使用列的类型小的创建索引" class="headerlink" title="使用列的类型小的创建索引"></a>使用列的类型小的创建索引</h4><h4 id="使用字符前缀创建索引"><a href="#使用字符前缀创建索引" class="headerlink" title="使用字符前缀创建索引"></a>使用字符前缀创建索引</h4><blockquote>
<p>【 强制 】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本</p>
<p>区分度决定索引长度。</p>
<p>引自：《Alibaba Java 开发手册》</p>
</blockquote>
<p>索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会 高达</p>
<p>90% 以上 ，可以使用 count(distinct left(列名, 索引长度))/count(*) 的区分度来确定。</p>
<h4 id="使用区分度（散列度）高的列作为索引"><a href="#使用区分度（散列度）高的列作为索引" class="headerlink" title="使用区分度（散列度）高的列作为索引"></a>使用区分度（散列度）高的列作为索引</h4><p>区分度（散列度）越高，重复的内容越少，检索效率也就越高。</p>
<h4 id="使用频繁的列放到联合索引的左侧（最左前缀法则）"><a href="#使用频繁的列放到联合索引的左侧（最左前缀法则）" class="headerlink" title="使用频繁的列放到联合索引的左侧（最左前缀法则）"></a>使用频繁的列放到联合索引的左侧（最左前缀法则）</h4><p>这样也可以较少的建立一些索引。同时，由于”最左前缀原则”，可以增加联合索引的使用率。</p>
<h4 id="多个字段都要创建索引的情况下，联合索引优于单列索引"><a href="#多个字段都要创建索引的情况下，联合索引优于单列索引" class="headerlink" title="多个字段都要创建索引的情况下，联合索引优于单列索引"></a>多个字段都要创建索引的情况下，联合索引优于单列索引</h4><h4 id="限制索引的数目"><a href="#限制索引的数目" class="headerlink" title="限制索引的数目"></a>限制索引的数目</h4><p>一张表的索引数目最好不要超过 6 个</p>
<h3 id="哪些情况下不适合创建索引"><a href="#哪些情况下不适合创建索引" class="headerlink" title="哪些情况下不适合创建索引"></a>哪些情况下不适合创建索引</h3><h4 id="条件查询中使用不到的列，不要创建索引"><a href="#条件查询中使用不到的列，不要创建索引" class="headerlink" title="条件查询中使用不到的列，不要创建索引"></a>条件查询中使用不到的列，不要创建索引</h4><h4 id="数据量小的表不要创建索引"><a href="#数据量小的表不要创建索引" class="headerlink" title="数据量小的表不要创建索引"></a>数据量小的表不要创建索引</h4><p>大可不必，小题大做</p>
<h4 id="大量重复数据的列，不要创建索引"><a href="#大量重复数据的列，不要创建索引" class="headerlink" title="大量重复数据的列，不要创建索引"></a>大量重复数据的列，不要创建索引</h4><p>因为检索时需要先访问索引，再访问表，如果重复的数据过多，可能效率还不如全表扫描。</p>
<p><strong>结论：当数据重复度大，比如 高于 10% 的时候，也不需要对这个字段使用索引。</strong></p>
<h4 id="避免对经常更新表建立索引"><a href="#避免对经常更新表建立索引" class="headerlink" title="避免对经常更新表建立索引"></a>避免对经常更新表建立索引</h4><p>索引的维护也需要时间成本，频繁对索引结构进行维护，会导致更新效率变低。</p>
<h4 id="不建议使用无序的值作为索引"><a href="#不建议使用无序的值作为索引" class="headerlink" title="不建议使用无序的值作为索引"></a>不建议使用无序的值作为索引</h4><p>例如身份证、UUID(在索引比较时需要转为ASCII，并且插入时可能造成页分裂)、MD5、HASH、无序长字</p>
<p>符串等。</p>
<h4 id="删除很少使用的索引"><a href="#删除很少使用的索引" class="headerlink" title="删除很少使用的索引"></a>删除很少使用的索引</h4><h4 id="不要定义冗余或重复索引"><a href="#不要定义冗余或重复索引" class="headerlink" title="不要定义冗余或重复索引"></a>不要定义冗余或重复索引</h4><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>索引是一把双刃剑，加速检索速度的同时，也会占用磁盘空间，降低更新的效率，所以我们要合理利用索引。</p>
<h2 id="Explan"><a href="#Explan" class="headerlink" title="Explan"></a>Explan</h2><p>Explan 语句输出的各个列的作用如下：</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>在一个大的查询语句中每个 select 关键字都对应一个唯一的 id</td>
</tr>
<tr>
<td>select_type</td>
<td>select 关键字对应的那个查询的类型</td>
</tr>
<tr>
<td>table</td>
<td>表名</td>
</tr>
<tr>
<td>partitions</td>
<td>匹配的分区信息</td>
</tr>
<tr>
<td>type</td>
<td>针对单表的访问方法</td>
</tr>
<tr>
<td>possible_keys</td>
<td>可能用到的索引</td>
</tr>
<tr>
<td>key</td>
<td>实际上使用的索引</td>
</tr>
<tr>
<td>key_len</td>
<td>实际使用到的索引长度</td>
</tr>
<tr>
<td>ref</td>
<td>当使用的索引列等值查询时，与索引列进行等值匹配的对象信息</td>
</tr>
<tr>
<td>rows</td>
<td>预估的需要读取的记录条数</td>
</tr>
<tr>
<td>filterred</td>
<td>某个表经过搜索条件过滤后剩余记录条数的百分比</td>
</tr>
<tr>
<td>Extra</td>
<td>一些额外的信息</td>
</tr>
</tbody></table>
<h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p>EXPLAIN 语句输出的每条记录都对应着某个单表的访问方法，该条记录的 table 列代表着该表的表名。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1;</span><br></pre></td></tr></table></figure>

<h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><ul>
<li><p>查询语句中每出现一个 SELECT 关键字，就会为它分配一个唯一的 id 值。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>在连接查询的执行计划中，每个表都会对应一条记录，但是这些记录的id值都是相同的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2;</span><br></pre></td></tr></table></figure></li>
<li><p>在连接查询的执行计划中，每个表都会对应一条记录，这些记录的id列的值是相同的，出现在前边的表表示驱动表，出现在后边的表表示被驱动表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2;</span><br></pre></td></tr></table></figure></li>
<li><p>查询优化器可能对涉及子查询的查询语句进行重写，从而转换为连接查询。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> key1 <span class="keyword">FROM</span> s2) <span class="keyword">OR</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><ul>
<li>**id **如果相同，可以认为是一组，从上往下顺序执行</li>
<li>**在所有组中，id **值越大，优先级越高，越先执行</li>
<li>关注点：id 号每个号码，表示一趟独立的查询, 一个 sql 的查询趟数越少越好</li>
</ul>
<h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><table>
<thead>
<tr>
<th>select_type</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>SIMPLE</td>
<td>Simple SELECT (not using UNION or subqueries)</td>
</tr>
<tr>
<td>PRIMARY</td>
<td>Outermost SELECT</td>
</tr>
<tr>
<td>UNION</td>
<td>Second or later SELECT statement in a UNION</td>
</tr>
<tr>
<td>UNION RESULT</td>
<td>Result of a UNION</td>
</tr>
<tr>
<td>SUBQUERY</td>
<td>First SELECT in subquery</td>
</tr>
<tr>
<td>DEPENDENT SUBQUERY</td>
<td>First SELECT in subquery, dependent on outer query</td>
</tr>
<tr>
<td>DEPENDENT UNION</td>
<td>Second or later SELECT statement in a UNION, dependent on outer query</td>
</tr>
<tr>
<td>DERIVED</td>
<td>Derived table</td>
</tr>
<tr>
<td>MATERIALIZED</td>
<td>Materialized subquery</td>
</tr>
<tr>
<td>UNCACHEABLE SUBQUERY</td>
<td>A subquery for which the result cannot be cached and must be re-evaluated for each row of the outer query</td>
</tr>
<tr>
<td>UNCACHEABLE UNION</td>
<td>The second or later select in a UNION that belongs to an uncacheable subquery (see UNCACHEABLE SUBQUERY)</td>
</tr>
</tbody></table>
<h3 id="partitions"><a href="#partitions" class="headerlink" title="partitions"></a>partitions</h3><h3 id="type（重要）"><a href="#type（重要）" class="headerlink" title="type（重要）"></a>type（重要）</h3><h4 id="system"><a href="#system" class="headerlink" title="system"></a>system</h4><p>当表中只有一条记录并且该表使用的存储引擎的统计数据是精确的，比如MyISAM、Memory，那么对该表的访问方法就是 system 。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t(i <span class="type">INT</span>) ENGINE<span class="operator">=</span>MYISAM;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t <span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t;</span><br></pre></td></tr></table></figure>

<h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><p>当我们根据主键或者唯一二级索引列与常数进行等值匹配时，对单表的访问方法就是 const。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">10005</span>;</span><br></pre></td></tr></table></figure>

<h4 id="eq-ref"><a href="#eq-ref" class="headerlink" title="eq_ref"></a>eq_ref</h4><p>在连接查询时，如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问的（如果该主键或者唯一二级索引是联合索引的话，所有的索引列都必须进行等值比较），则对该被驱动表的访问方法就是 eq_ref 。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.id <span class="operator">=</span> s2.id;</span><br></pre></td></tr></table></figure>

<h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h4><p>当通过普通的二级索引列与常量进行等值匹配时来查询某个表，那么对该表的访问方法就可能是 ref。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="fulltext"><a href="#fulltext" class="headerlink" title="fulltext"></a>fulltext</h4><h4 id="ref-or-null"><a href="#ref-or-null" class="headerlink" title="ref_or_null"></a>ref_or_null</h4><p>当对普通二级索引进行等值匹配查询，该索引列的值也可以是 NULL 值时，那么对该表的访问方法就可能是 ref_or_null。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">OR</span> key1 <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>

<h4 id="index-merge"><a href="#index-merge" class="headerlink" title="index_merge"></a>index_merge</h4><p>一般情况下对于某个表的查询只能使用到一个索引，但我们唠叨单表访问方法时特意强调了在某些场景下可以使用 Intersection 、 Union 、 Sort-Union 这三种索引合并的方式来执行查询。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">OR</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="unique-subquery"><a href="#unique-subquery" class="headerlink" title="unique_subquery"></a>unique_subquery</h4><p>类似于两表连接中被驱动表的 eq_ref 访问方法， unique_subquery 是针对在一些包含 IN 子查询的查询语句中，如果查询优化器决定将 IN 子查询转换为 EXISTS 子查询，而且子查询可以使用到主键进行等值匹配的话，那么该子查询执行计划的 type 列的值就是 unique_subquery 。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 </span><br><span class="line"> <span class="keyword">WHERE</span> key2 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> s2 <span class="keyword">WHERE</span> s1.key1 <span class="operator">=</span> s2.key1) <span class="keyword">OR</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="index-subquery"><a href="#index-subquery" class="headerlink" title="index_subquery"></a>index_subquery</h4><p>index_subquery 与 unique_subquery 类似，只不过访问子查询中的表时使用的是普通的索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 </span><br><span class="line"><span class="keyword">WHERE</span> key2 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> s2 <span class="keyword">WHERE</span> s1.key1 <span class="operator">=</span> s2.key1) <span class="keyword">OR</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="range"><a href="#range" class="headerlink" title="range"></a>range</h4><p>如果使用索引获取某些 范围区间 的记录，那么就可能使用到 range 访问方法。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">&gt;</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">AND</span> key1 <span class="operator">&lt;</span> <span class="string">&#x27;b&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="index"><a href="#index" class="headerlink" title="index"></a>index</h4><p>当我们可以使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是 index。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> key_part2 <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key_part3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="all"><a href="#all" class="headerlink" title="all"></a>all</h4><p>全表扫描。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1;</span><br></pre></td></tr></table></figure>

<h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p><strong>结果值从最好到最坏依次是： system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL 。</strong></p>
<p>SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，最好是 consts 级别。（阿里巴巴开发手册要求）</p>
<h3 id="possible-keys-和-key"><a href="#possible-keys-和-key" class="headerlink" title="possible_keys 和 key"></a>possible_keys 和 key</h3><ul>
<li>possible：可能使用到的索引</li>
<li>key：使用的索引</li>
</ul>
<p>possible_keys 列中的值并不是越多越好，可能使用的索引越多，查询优化器计算查询成本时就得花费更长时间，所以如果可以的话，尽量删除那些用不到的索引</p>
<h3 id="key-len（重要）"><a href="#key-len（重要）" class="headerlink" title="key_len（重要）"></a>key_len（重要）</h3><p>key_len：实际使用到的索引长度（字节数）</p>
<p>帮你检查<code>是否充分的利用上了索引</code>，<code>值越大越好</code>,主要针对于联合索引，有一定的参考意义。</p>
<ul>
<li>对于使用固定长度类型的索引列来说，它实际占用的存储空间的最大长度就是该固定值，对于指定字符集的</li>
<li>变长类型的索引列来说，比如某个索引列的类型是 VARCHAR(100) ，使用的字符集是 utf8 ，那么该列实际占</li>
<li>用的最大存储空间就是 100 × 3 = 300 个字节。</li>
<li>如果该索引列可以存储 NULL 值，则 key_len 比不可以存储 NULL 值时多1个字节。</li>
<li>对于变长字段来说，都会有2个字节的空间来存储该变长列的实际长度。</li>
</ul>
<h3 id="ref-1"><a href="#ref-1" class="headerlink" title="ref"></a>ref</h3><p>当使用索引列等值匹配的条件去执行查询时，也就是在访问方法是 const 、 eq_ref 、 ref 、 ref_or_null 、unique_subquery 、index_subquery 其中之一时， ref 列展示的就是与索引列作等值匹配的东东是个啥，比如只是一个常数或者是某个列。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.id <span class="operator">=</span> s2.id;</span><br><span class="line"> </span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s2.key1 <span class="operator">=</span> <span class="built_in">UPPER</span>(s1.key1);</span><br></pre></td></tr></table></figure>

<h3 id="rows（重要）"><a href="#rows（重要）" class="headerlink" title="rows（重要）"></a>rows（重要）</h3><p>rows：预估的需要读取的记录条数，值越小越好</p>
<p>如果查询优化器决定使用全表扫描的方式对某个表执行查询时，执行计划的 rows 列就代表预计需要扫描的行数，如果使用索引来执行查询时，执行计划的 rows 列就代表预计扫描的索引记录行数。</p>
<h3 id="filtered"><a href="#filtered" class="headerlink" title="filtered"></a>filtered</h3><p>filtered: 某个表经过搜索条件过滤后剩余记录条数的百分比</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#如果使用的是索引执行的单表扫描，那么计算时需要估计出满足除使用</span><br><span class="line">#到对应索引的搜索条件外的其他搜索条件的记录有多少条。</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">&gt;</span> <span class="string">&#x27;z&#x27;</span> <span class="keyword">AND</span> common_field <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#对于单表查询来说，这个filtered列的值没什么意义，我们`更关注在连接查询</span><br><span class="line">#中驱动表对应的执行计划记录的filtered值`，它决定了被驱动表要执行的次数(即：<span class="keyword">rows</span> <span class="operator">*</span> filtered)</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.key1 <span class="operator">=</span> s2.key1 <span class="keyword">WHERE</span> s1.common_field <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><p>Extra：一些额外的信息，更准确的理解MySQL到底将如何执行给定的查询语句。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">#当查询语句的没有`<span class="keyword">FROM</span>`子句时将会提示该额外信息</span><br><span class="line"> EXPLAIN <span class="keyword">SELECT</span> <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">#查询语句的`<span class="keyword">WHERE</span>`子句永远为`<span class="literal">FALSE</span>`时将会提示该额外信息</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> <span class="number">1</span> <span class="operator">!=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">#当我们使用全表扫描来执行对某个表的查询，并且该语句的`<span class="keyword">WHERE</span>`</span><br><span class="line">#子句中有针对该表的搜索条件时，在`Extra`列中会提示上述额外信息。</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> common_field <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#当使用索引访问来执行对某个表的查询，并且该语句的`<span class="keyword">WHERE</span>`子句中</span><br><span class="line">#有除了该索引包含的列之外的其他搜索条件时，在`Extra`列中也会提示上述额外信息。</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">AND</span> common_field <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#当查询列表处有`MIN`或者`MAX`聚合函数，但是并没有符合`<span class="keyword">WHERE</span>`子句中</span><br><span class="line">#的搜索条件的记录时，将会提示该额外信息</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="built_in">MIN</span>(key1) <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;abcdefg&#x27;</span>;</span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="built_in">MIN</span>(key1) <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;NlPros&#x27;</span>; #NlPros 是 s1表中key1字段真实存在的数据</span><br><span class="line"></span><br><span class="line">#<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> s1 limit <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">#当我们的查询列表以及搜索条件中只包含属于某个索引的列，也就是在可以</span><br><span class="line">#使用覆盖索引的情况下，在`Extra`列将会提示该额外信息。比方说下边这个查询中只</span><br><span class="line">#需要用到`idx_key1`而不需要回表操作：</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> key1,id <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#有些搜索条件中虽然出现了索引列，但却不能使用到索引</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">&gt;</span> <span class="string">&#x27;z&#x27;</span> <span class="keyword">AND</span> key1 <span class="keyword">LIKE</span> <span class="string">&#x27;%a&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#在连接查询执行过程中，当被驱动表不能有效的利用索引加快访问速度，MySQL一般会为</span><br><span class="line">#其分配一块名叫`<span class="keyword">join</span> buffer`的内存块来加快查询速度，也就是我们所讲的`基于块的嵌套循环算法`</span><br><span class="line">#见课件说明</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.common_field <span class="operator">=</span> s2.common_field;</span><br><span class="line"></span><br><span class="line">#当我们使用左（外）连接时，如果`<span class="keyword">WHERE</span>`子句中包含要求被驱动表的某个列等于`<span class="keyword">NULL</span>`值的搜索条件，</span><br><span class="line">#而且那个列又是不允许存储`<span class="keyword">NULL</span>`值的，那么在该表的执行计划的Extra列就会提示`<span class="keyword">Not</span> <span class="keyword">exists</span>`额外信息</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.key1 <span class="operator">=</span> s2.key1 <span class="keyword">WHERE</span> s2.id <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line">#如果执行计划的`Extra`列出现了`<span class="keyword">Using</span> <span class="keyword">intersect</span>(...)`提示，说明准备使用`<span class="keyword">Intersect</span>`索引</span><br><span class="line">#合并的方式执行查询，括号中的`...`表示需要进行索引合并的索引名称；</span><br><span class="line">#如果出现了`<span class="keyword">Using</span> <span class="keyword">union</span>(...)`提示，说明准备使用`<span class="keyword">Union</span>`索引合并的方式执行查询；</span><br><span class="line">#出现了`<span class="keyword">Using</span> sort_union(...)`提示，说明准备使用`Sort<span class="operator">-</span><span class="keyword">Union</span>`索引合并的方式执行查询。</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">OR</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#当我们的`LIMIT`子句的参数为`<span class="number">0</span>`时，表示压根儿不打算从表中读出任何记录，将会提示该额外信息</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 LIMIT <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">#有一些情况下对结果集中的记录进行排序是可以使用到索引的。</span><br><span class="line">#比如：</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> key1 LIMIT <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">#很多情况下排序操作无法使用到索引，只能在内存中（记录较少的时候）或者磁盘中（记录较多的时候）</span><br><span class="line">#进行排序，MySQL把这种在内存中或者磁盘上进行排序的方式统称为文件排序（英文名：`filesort`）。</span><br><span class="line"> </span><br><span class="line">#如果某个查询需要使用文件排序的方式执行查询，就会在执行计划的`Extra`列中显示`<span class="keyword">Using</span> filesort`提示</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> common_field LIMIT <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">#在许多查询的执行过程中，MySQL可能会借助临时表来完成一些功能，比如去重、排序之类的，比如我们</span><br><span class="line">#在执行许多包含`<span class="keyword">DISTINCT</span>`、`<span class="keyword">GROUP</span> <span class="keyword">BY</span>`、`<span class="keyword">UNION</span>`等子句的查询过程中，如果不能有效利用索引来完成</span><br><span class="line">#查询，MySQL很有可能寻求通过建立内部的临时表来执行查询。如果查询中使用到了内部的临时表，在执行</span><br><span class="line">#计划的`Extra`列将会显示`<span class="keyword">Using</span> temporary`提示</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> common_field <span class="keyword">FROM</span> s1;</span><br><span class="line"></span><br><span class="line">#EXPLAIN <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> key1 <span class="keyword">FROM</span> s1;</span><br><span class="line"></span><br><span class="line">#同上。</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> common_field, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> amount <span class="keyword">FROM</span> s1 <span class="keyword">GROUP</span> <span class="keyword">BY</span> common_field;</span><br><span class="line"></span><br><span class="line">#执行计划中出现`<span class="keyword">Using</span> temporary`并不是一个好的征兆，因为建立与维护临时表要付出很大成本的，所以</span><br><span class="line">#我们`最好能使用索引来替代掉使用临时表`。比如：扫描指定的索引idx_key1即可</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> key1, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> amount <span class="keyword">FROM</span> s1 <span class="keyword">GROUP</span> <span class="keyword">BY</span> key1;</span><br></pre></td></tr></table></figure>

<h3 id="JSON-格式化的-Explan"><a href="#JSON-格式化的-Explan" class="headerlink" title="JSON 格式化的 Explan"></a>JSON 格式化的 Explan</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#json格式的explain</span><br><span class="line">EXPLAIN FORMAT<span class="operator">=</span>JSON <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.key1 <span class="operator">=</span> s2.key2 </span><br><span class="line"><span class="keyword">WHERE</span> s1.common_field <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="索引优化与查询优化"><a href="#索引优化与查询优化" class="headerlink" title="索引优化与查询优化"></a>索引优化与查询优化</h2><h3 id="使用索引的最佳场景和注意事项"><a href="#使用索引的最佳场景和注意事项" class="headerlink" title="使用索引的最佳场景和注意事项"></a>使用索引的最佳场景和注意事项</h3><h5 id="最佳场景"><a href="#最佳场景" class="headerlink" title="最佳场景"></a>最佳场景</h5><ul>
<li><p>全值匹配 </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age<span class="operator">=</span><span class="number">30</span>;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age<span class="operator">=</span><span class="number">30</span> <span class="keyword">AND</span> classId<span class="operator">=</span><span class="number">4</span>;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age<span class="operator">=</span><span class="number">30</span> <span class="keyword">AND</span> classId<span class="operator">=</span><span class="number">4</span> <span class="keyword">AND</span> NAME <span class="operator">=</span> <span class="string">&#x27;abcd&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age<span class="operator">=</span><span class="number">30</span> <span class="keyword">AND</span> classId<span class="operator">=</span><span class="number">4</span> <span class="keyword">AND</span> NAME <span class="operator">=</span> <span class="string">&#x27;abcd&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age <span class="keyword">ON</span> student(age);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_classid <span class="keyword">ON</span> student(age,classId);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_classid_name <span class="keyword">ON</span> student(age,classId,NAME);</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ul>
<li><p>索引是有序排列的，因此主键也要是依次递增的，避免==页分裂==的情况发生。</p>
</li>
<li><p>like 模糊查询优于使用函数的模糊查询，因为使用函数会导致索引失效，如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_name <span class="keyword">ON</span> student(NAME);</span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.name <span class="keyword">LIKE</span> <span class="string">&#x27;abc%&#x27;</span>;</span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="keyword">LEFT</span>(student.name,<span class="number">3</span>) <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span>; </span><br></pre></td></tr></table></figure></li>
<li><p>不同字符集的转换也可能导致索引失效，索引尽量统一使用 utf8mb4（兼容性好）</p>
</li>
</ul>
<h3 id="索引失效的场景"><a href="#索引失效的场景" class="headerlink" title="索引失效的场景"></a>索引失效的场景</h3><p>索引失效与否，都是查询优化器来决定的，如果全表扫描的成本比使用索引低，会选择全表扫描，反之亦然。所以下面索引失效的场景并不是绝对的，如果符合索引失效的条件，但最终还是使用了索引，代表优化器认为使用索引的成本还是比全表扫描低。（规则就是用来打破的）</p>
<h4 id="最左前缀法则"><a href="#最左前缀法则" class="headerlink" title="最左前缀法则"></a>最左前缀法则</h4><p>在联合索引中，如果条件列与联合索引左侧的列不匹配，则有可能索引失效。因为索引是有序的数据结构，联合索引是按照从左到右的顺序对索引列进行排序。如果条件列直接出现索引列右侧的列，则无法使用索引结构进行查询。</p>
<p>例：age,classId,NAME 三列组合成了一个联合索引，但 SQL WHERE 条件中，只出现了 classId 和 name 字段，索引最左侧的列没有出现，导致索引失效。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_classid_name <span class="keyword">ON</span> student(age,classId,NAME);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 条件列中不包含索引最左边的列，索引失效</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.classid<span class="operator">=</span><span class="number">1</span> <span class="keyword">AND</span> student.name <span class="operator">=</span> <span class="string">&#x27;abcd&#x27;</span>;	</span><br></pre></td></tr></table></figure>

<h4 id="计算、函数、类型转换"><a href="#计算、函数、类型转换" class="headerlink" title="计算、函数、类型转换"></a>计算、函数、类型转换</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_name <span class="keyword">ON</span> student(NAME);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 对索引列进行计算会导致索引失效</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE id, stuno, NAME <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> stuno<span class="operator">+</span><span class="number">1</span> <span class="operator">=</span> <span class="number">900001</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 对索引列使用函数方法会导致索引失效</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="keyword">LEFT</span>(student.name,<span class="number">3</span>) <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span>; </span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> id, stuno, NAME <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="built_in">SUBSTRING</span>(NAME, <span class="number">1</span>,<span class="number">3</span>)<span class="operator">=</span><span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 对索引列进行类型转换会导致索引失效</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="number">123</span>; # name 是 <span class="type">varchar</span> 类型，没带 <span class="string">&#x27;&#x27;</span> 会自动类型转换</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="范围条件右边的索引列"><a href="#范围条件右边的索引列" class="headerlink" title="范围条件右边的索引列"></a>范围条件右边的索引列</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_classId_name <span class="keyword">ON</span> student(age,classId,NAME);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- name 索引列失效，只使用了 age 和 classId</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student </span><br><span class="line"><span class="keyword">WHERE</span> student.age<span class="operator">=</span><span class="number">30</span> <span class="keyword">AND</span> student.classId<span class="operator">&gt;</span><span class="number">20</span> <span class="keyword">AND</span> student.name <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span> ; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 一样的结果，与条件列的顺序无关</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student </span><br><span class="line"><span class="keyword">WHERE</span> student.age<span class="operator">=</span><span class="number">30</span> <span class="keyword">AND</span> student.name <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span> <span class="keyword">AND</span> student.classId<span class="operator">&gt;</span><span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<h4 id="不等于条件（-或-lt-gt-）"><a href="#不等于条件（-或-lt-gt-）" class="headerlink" title="不等于条件（!= 或 &lt;&gt;）"></a>不等于条件（!= 或 &lt;&gt;）</h4><p>在 Where 中使用 != 或 &lt;&gt; 有可能会导致索引失效</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_name <span class="keyword">ON</span> student(NAME);</span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.name <span class="operator">&lt;&gt;</span> <span class="string">&#x27;abc&#x27;</span> ;</span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.name <span class="operator">!=</span> <span class="string">&#x27;abc&#x27;</span> ;</span><br></pre></td></tr></table></figure>

<h4 id="is-not-null-无法使用索引"><a href="#is-not-null-无法使用索引" class="headerlink" title="is not null 无法使用索引"></a>is not null 无法使用索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- is null可以使用索引，is not null无法使用索引</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="keyword">IS</span> <span class="keyword">NULL</span>; </span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>

<h4 id="like-以通配符-开头"><a href="#like-以通配符-开头" class="headerlink" title="like 以通配符 % 开头"></a>like 以通配符 % 开头</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> NAME <span class="keyword">LIKE</span> <span class="string">&#x27;ab%&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 以 % 开头，索引失效</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> NAME <span class="keyword">LIKE</span> <span class="string">&#x27;%ab%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="or-前后存在非索引的列"><a href="#or-前后存在非索引的列" class="headerlink" title="or 前后存在非索引的列"></a>or 前后存在非索引的列</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_age <span class="keyword">ON</span> student(age);</span><br><span class="line"><span class="comment">-- 索引失效</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">10</span> <span class="keyword">OR</span> classid <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="comment">-- 创建索引后，再执行上面的 SQL，索引不会失效</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_cid <span class="keyword">ON</span> student(classid);</span><br></pre></td></tr></table></figure>

<h4 id="不同字符集的转换"><a href="#不同字符集的转换" class="headerlink" title="不同字符集的转换"></a>不同字符集的转换</h4><p>统一使用 utf8mb4( 5.5.3版本以上支持) 兼容性更好，统一字符集可以避免由于字符集转换产生的乱码。不同的字符集进行比较前需要进行转换会造成索引失效。</p>
<h3 id="查询优化-1"><a href="#查询优化-1" class="headerlink" title="查询优化"></a>查询优化</h3><h4 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h4><h5 id="连接查询原理"><a href="#连接查询原理" class="headerlink" title="连接查询原理"></a>连接查询原理</h5><p><strong>内连接</strong></p>
<ul>
<li><p>内连接中的WHERE子句和ON子句是等价的</p>
</li>
<li><p>内连接和外连接的根本区别就是在驱动表中的记录不符合 ON 子句中的连接条件时不会把该记录加入到最后的结</p>
<p>果集</p>
</li>
<li><p>由于在内连接中ON子句和WHERE子句是等价的，所以内连接中不要求强制写明ON子句</p>
</li>
<li><p>对于内连接来说，驱动表和被驱动表是可以互换的，并不会影响最后的查询结果</p>
</li>
</ul>
<p><strong>左右外连接</strong></p>
<ul>
<li>对于左（外）连接和右（外）连接来说，必须使用 ON 子句来指出连接条件</li>
<li>左外连接和右外连接的驱动表和被驱动表不能轻易互换</li>
</ul>
<p><strong>连接的过程</strong></p>
<ul>
<li><strong>嵌套循环连接：</strong>这个过程就像是一个嵌套的循环，所以这种驱动表只访问一次，但被驱动表却可能被多次访问，访问次数取决于</li>
</ul>
<p>对驱动表执行单表查询后的结果集中的记录条数的连接执行方式称之为 嵌套循环连接</p>
<ul>
<li><p><strong>使用索引可以加快连接速度</strong></p>
</li>
<li><p><strong>基于块的嵌套循环连接</strong></p>
</li>
</ul>
<h5 id="左右外连接"><a href="#左右外连接" class="headerlink" title="左右外连接"></a>左右外连接</h5><p>如果只能加一个索引，被驱动表一定要优先加索引。最好是驱动表和被驱动表都添加索引。</p>
<h5 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h5><ul>
<li>对于内连接来说，查询优化器可以决定谁作为驱动表，谁作为被驱动表出现的</li>
<li>对于内连接来讲，如果表的连接条件中只能有一个字段有索引，则有索引的字段所在的表会被作为被驱动表出现。</li>
<li>对于内连接来说，在两个表的连接条件都存在索引的情况下，会选择小表作为驱动表。“小表驱动大表”</li>
</ul>
<h5 id="连接查询小结"><a href="#连接查询小结" class="headerlink" title="连接查询小结"></a>连接查询小结</h5><ul>
<li>保证被驱动表的 JOIN 字段已经创建了索引</li>
<li>需要 JOIN 的字段，数据类型保持绝对一致。</li>
<li>LEFT JOIN 时，选择小表作为驱动表， 大表作为被驱动表 。减少外层循环的次数。</li>
<li>INNER JOIN 时，MySQL会自动将 小结果集的表选为驱动表 。选择相信MySQL优化策略。</li>
<li>能够直接多表关联的尽量直接关联，不用子查询。(减少查询的趟数)</li>
<li>不建议使用子查询，建议将子查询SQL拆开结合程序多次查询，或使用 JOIN 来代替子查询。</li>
<li>衍生表建不了索引</li>
</ul>
<h4 id="子查询优化"><a href="#子查询优化" class="headerlink" title="子查询优化"></a>子查询优化</h4><h5 id="子查询原理"><a href="#子查询原理" class="headerlink" title="子查询原理"></a>子查询原理</h5><ol>
<li> 执行子查询时，MySQL需要为内层查询语句的查询结果 建立一个临时表 ，然后外层查询语句从临时表中查询记录。查询完毕后，再 撤销这些临时表 。这样会消耗过多的 CPU 和 IO 资源，产生大量的慢查询。</li>
<li>子查询的结果集存储的临时表，不论是内存临时表还是磁盘临时表都 不会存在索引 ，所以查询性能会受到一定的影响。</li>
<li>对于返回结果集比较大的子查询，其对查询性能的影响也就越大。</li>
</ol>
<h5 id="优化策略"><a href="#优化策略" class="headerlink" title="优化策略"></a>优化策略</h5><ul>
<li><strong>可以使用连接（JOIN）查询来替代子查询。</strong>连接查询 不需要建立临时表 ，其 速度比子查询要快 ，如果查询中使用索引的话，性能就会更好。</li>
<li>尽量不要使用NOT IN 或者 NOT EXISTS，用 LEFT JOIN xxx ON xx WHERE xx IS NULL替代</li>
</ul>
<h4 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h4><h4 id="GROUP-BY-优化"><a href="#GROUP-BY-优化" class="headerlink" title="GROUP BY 优化"></a>GROUP BY 优化</h4><h4 id="优化分页查询"><a href="#优化分页查询" class="headerlink" title="优化分页查询"></a>优化分页查询</h4><h4 id="优先考虑覆盖索引"><a href="#优先考虑覆盖索引" class="headerlink" title="优先考虑覆盖索引"></a>优先考虑覆盖索引</h4><p>一个所以包含了满足查询结果的数据就叫做覆盖索引（索引列+主键）</p>
<p><strong>覆盖索引的优点：</strong></p>
<ul>
<li>避免 innodb 表进行索引的二次查询（回表）</li>
<li>可以把随机 IO 变成顺序 IO</li>
</ul>
<p><strong>覆盖索引的缺点：</strong></p>
<ul>
<li>索引字段的维护是有代价的，因此建立冗余索引来支持覆盖索引需要权衡考虑。</li>
</ul>
<h4 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h4><h4 id="普通索引-VS-唯一索引"><a href="#普通索引-VS-唯一索引" class="headerlink" title="普通索引 VS 唯一索引"></a>普通索引 VS 唯一索引</h4><h4 id="其他查询优化策略"><a href="#其他查询优化策略" class="headerlink" title="其他查询优化策略"></a>其他查询优化策略</h4><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li>《MySQL 是怎样运行的：从根儿上理解 MySQL》</li>
<li>宋红康老师的 MySQL 教程：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1iq4y1u7vj">https://www.bilibili.com/video/BV1iq4y1u7vj</a></li>
</ul>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://example.com/2023/05/19/MySQL/mysql-%E8%BF%9B%E9%98%B6/" title="MySQL 进阶" target="_blank" rel="external">http://example.com/2023/05/19/MySQL/mysql-进阶/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


    </div>
  </article>
  
    
  <section id="comments">
  	
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2023/06/08/java%E5%9F%BA%E7%A1%80/23%E7%A7%8DJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%BB%91%E9%A9%AC/" title="23种设计模式（Java 实现方式）"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2023/04/28/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/Junit5-%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/" title="Junit 踩坑记录"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn " data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">    <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  
  <div class="bar-right">
    
  </div>
  </div>
</nav>
  


</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/klay11K/klay11K.github.io" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





   






</body>
</html>